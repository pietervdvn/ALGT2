module Assets where



import qualified Data.ByteString as B
import qualified Data.ByteString.Builder as B
import Data.ByteString.Lazy (toStrict)
import System.IO
import Control.DeepSeq
import Data.Time

-- Automatically generated
-- This file contains all assets, loaded via 'unsafePerformIO' or hardcoded as string, not to need IO for assets

readFile'		:: FilePath -> IO String
readFile' str = do	h <- openFile str ReadMode
			s <- hGetContents h
			s `deepseq` hClose h
			return s

timeCreated	:: UTCTime
timeCreated	= read "2018-06-22 23:34:09.947091238 UTC"
allAssets	:: [(FilePath, String)]
allAssets	= [("Functions.language", _Functions_language)
			, ("TestLanguage.language", _TestLanguage_language)
			, ("Readme.md", _Readme_md)
			, ("Resources/InterpreterHelp.md", _Resources_InterpreterHelp_md)
			, ("Resources/Template.language", _Resources_Template_language)
			, ("Resources/RuleSimple.svg", _Resources_RuleSimple_svg)
			, ("Resources/Readme.md", _Resources_Readme_md)
			, ("TestInput/LoopingSupertypes.language", _TestInput_LoopingSupertypes_language)
			, ("TestInput/Faulty/TitleMismatch.language", _TestInput_Faulty_TitleMismatch_language)
			, ("TestInput/Faulty/LeftRecursiveSyntax.language", _TestInput_Faulty_LeftRecursiveSyntax_language)
			, ("TestInput/Faulty/FunctionDuplicateNameTest.language", _TestInput_Faulty_FunctionDuplicateNameTest_language)
			, ("TestInput/Faulty/TestShadowing.language", _TestInput_Faulty_TestShadowing_language)
			, ("TestInput/Faulty/SyntaxUndeclared.language", _TestInput_Faulty_SyntaxUndeclared_language)
			, ("TestInput/Faulty/FunctionIncorrectNameTest.language", _TestInput_Faulty_FunctionIncorrectNameTest_language)
			, ("TestInput/Faulty/FunctionTyperTest.language", _TestInput_Faulty_FunctionTyperTest_language)
			, ("TestInput/Faulty/VariableTypingErrors.language", _TestInput_Faulty_VariableTypingErrors_language)
			, ("TestInput/Faulty/Relations/NotLocal.language", _TestInput_Faulty_Relations_NotLocal_language)
			, ("TestInput/Faulty/Relations/DuplicateRelation.language", _TestInput_Faulty_Relations_DuplicateRelation_language)
			, ("TestInput/Faulty/Relations/EmptyLine.language", _TestInput_Faulty_Relations_EmptyLine_language)
			, ("TestInput/Faulty/Relations/UnknownTypeRelation.language", _TestInput_Faulty_Relations_UnknownTypeRelation_language)
			, ("TestInput/Faulty/Relations/IncorrectRule.language", _TestInput_Faulty_Relations_IncorrectRule_language)
			, ("TestInput/Faulty/Relations/AllOutRel.language", _TestInput_Faulty_Relations_AllOutRel_language)
			, ("TestInput/Faulty/Relations/NotDeclared.language", _TestInput_Faulty_Relations_NotDeclared_language)
			, ("TestInput/Faulty/Relations/Relation.language", _TestInput_Faulty_Relations_Relation_language)
			, ("TestInput/Faulty/Relations/TypeErr.language", _TestInput_Faulty_Relations_TypeErr_language)
			, ("TestInput/Faulty/Relations/UnkownTypeRelation.language", _TestInput_Faulty_Relations_UnkownTypeRelation_language)
			, ("TestInput/Nested/Z.language", _TestInput_Nested_Z_language)
			, ("TestInput/Nested/X.language", _TestInput_Nested_X_language)
			, ("TestInput/Nested/L.language", _TestInput_Nested_L_language)
			, ("TestInput/Nested/Y.language", _TestInput_Nested_Y_language)
			, ("ALGT/Builtins.language", _ALGT_Builtins_language)
			, ("ALGT/Readme.md", _ALGT_Readme_md)
			, ("ALGT/Native/Syntax.language", _ALGT_Native_Syntax_language)
			, ("ALGT/Native/Functions.language", _ALGT_Native_Functions_language)
			, ("ALGT/Native/ALGT.language", _ALGT_Native_ALGT_language)
			, ("ALGT/Native/Helper.language", _ALGT_Native_Helper_language)
			, ("ALGT/Native/Relations.language", _ALGT_Native_Relations_language)
			, ("ALGT/Sugared/Syntax.language", _ALGT_Sugared_Syntax_language)
			, ("MetaSyntax/Syntax.language", _MetaSyntax_Syntax_language)
			, ("MetaSyntax/Functions.language", _MetaSyntax_Functions_language)
			, ("MetaSyntax/ALGT.language", _MetaSyntax_ALGT_language)
			, ("MetaSyntax/Helper.language", _MetaSyntax_Helper_language)
			, ("MetaSyntax/Relations.language", _MetaSyntax_Relations_language)
			, ("TestLanguages/STFL.language", _TestLanguages_STFL_language)
			]
_Functions_language
	 = "import Syntax\n\n Functions\n***********\n\n# This file implements the syntax of metafunctions\n# As this file is part of the bootstrap for language definitions, only the syntax part can be used. Adding a metafunction section will cause a hang of ALGT\n# This is because, in order to read metafunctions, this language should be fully parsed - if this language would contain metafunctions, it could not be fully evaluated\n\n# Pietervdvn\n\n# Imports are injected fakely\n# Imports are:\n# Syntax (nls, nl, ident, typeIdent)\n#\n\n Syntax\n========\n\n\n\n\n# The symbol between two types in the signature\ntypeSep\t\t::= \"*\"\n\t\t| \"\215\"\t\n\nlastTypeSep\t::= \"->\" | \"\8594\" \n\n\ntypes\t\t::= Syntax.typeIdent typeSep types | Syntax.typeIdent\n\n# The type signature\nsignature\t::= Identifier \":\" types lastTypeSep Syntax.typeIdent\n\t\t|   Identifier \":\" Syntax.typeIdent\t\t\t# This would be a constant\n\n\n\narguments\t::= expression \",\" arguments | expression\nfuncCall\t~~= Syntax.ident \"(\" Whitespace arguments Whitespace \")\"\n\nascription\t::= expressionTerm \":\" Syntax.typeIdent\nsplitExpression\t::= expressionTerm \"&\" expression\n\n# Concatation of expressions; tabs are not allowed\nconcatExpressions\t~~= expressionTerm \" \" expression\n\n# The metaExpressions/patterns that can be used (note: the comments are in a special format: example, name, behaviour in patterns, behaviour in arguments)\n# If a function can not match any expression, an error is generated\nexpressionTerm\t::= funcCall\t# \"f(a, 5)\", \"Function call\", \"Evaluates the function, matches if the argument equals the result. Can only use variables which are declared left of this pattern. If the function fails (gives an error), the pattern fails too and the next clause is tried\", \"Evaluate this function\"\n\t\t| Identifier\t#  \"x\",\t\"Variable\",\"Captures the argument as the name. If multiple are used in the same pattern, the captured arguments should be the same or the match fails.\"\n\t\t| \"_\"\t\t# \"_\", \"Wildcard\", \"Captures the argument and ignores it\", \"_Not defined_\"\n\t\t| Number\t# \"42\", \"Number\", \"Argument should be exactly this number\", \"This number\"\n\t\t| String \t# \"Token\", \"Literal\", \"Argument should be exactly this string\", \"This string\"\n\t\t| \"(\" expression \")\"\t# \"(x y z)\", \"Parens\", \"Groups a pattern\", \"Groups an expression\"\n\n\n# A full expression, eventually a sequence\nexpression\t::=  ascription\t# \"a:type\", \"Ascription\", \"Check that the argument is an element of `type`\", \"Checks that an expression is of a type. Bit useless to use within expressions\"\n\t\t| splitExpression # \"x&y\", \"Capture\", \"Match the argument against both patterns\", \"Execute both `x` and `y`, check that they are the same\"\n\t\t| concatExpressions\n\t\t| expressionTerm\n\n# A single clause in a metafunction\neqSign\t\t~~= Syntax.nl \"\\t\" Whitespace \"=\" | \"=\"\nfuncClause\t::= Identifier \"(\" arguments \")\" eqSign expression Syntax.nl\nfuncClauses\t::= funcClause funcClauses | funcClause\n\n# A full function, including leading docstring\nfunction\t::= Syntax.nls signature Syntax.nl funcClauses\n\n# Full function section definition\nfunctions\t::= function functions | function\n\n\n"
_TestLanguage_language
	 = "\n Test Language\n*****************\n\n# Blabla\n\nSyntax\n======\n\nbool\t::= \"True\" | \"False\"\nint\t::= Number\n\nexpr\t::= bool | int\nexprSum\t::= expr op exprSum | expr\n\nop\t::= \"&\" | \"+\" \n\n\ntuple\t::= expr expr\n\n\nFunctions\n=========\n\n# Inverts a boolean\nnot\t\t: bool -> bool\nnot(\"True\")\t= \"False\"\nnot(\"False\")\t= \"True\"\n\nand\t\t: bool * bool -> bool\nand(\"True\", \"True\")\n\t\t= \"True\"\nand(_, _)\t= \"False\"\n\nnand\t\t: bool * bool -> bool\nnand(a, b)\t= not(and(a, b))\n\n\nor\t\t: bool * bool -> bool\nor(not(\"True\"), not(\"True\")) = \"False\"\nor(_, _)\t= \"True\"\n\n\n Relations\n===========\n\n(\8594) : exprSum (in) * exprSum (out); Pronounced as \"smallstep\"\n\n\n Rules\n=======\n\n ------------------------------- [and]\n  (\8594) \"True\" \"&\" \"True\", \"True\"\n\n"
_Readme_md
	 = ""
_Resources_InterpreterHelp_md
	 = "Welcome in the interactive interpreter.\n\n Basic usage\n=============\n\nIn the interpreter, you can interpret functions from the loaded module.\nFor example, if STFL is loaded, typing `not(\"True\")` will yield `False`\n\n\n Other commands\n================\n\nSome special commands are provided as well. These commands are: \n"
_Resources_Template_language
	 = "# Hello! Welcome in the ALGT template/tutorial.\n# Reading these comments will guide you through your first language\n#\n# Note that this tool is meant for programmers which have some experience, especially in the field of language design\n\n\n# First of all, we start with imports. An imports you'll need practically every time, are the builtin values\n# These contain some often used syntactic forms and functions to work with numbers (such as `plus`)\n# Once you have some basic understandig of ALGT, you can head over to the source of this file and take a look to it \n# You'll find it at: https://github.com/pietervdvn/ALGT2/blob/master/src/Assets/ALGT/Builtins.language\n\nimport ALGT.Builtins\n\n\n# Next is the name of your language, followed by a line of stars:\n\n Template\n**********\n\n# This is a template and tutorial language. Text that comes here is picked up by ALGT as documentation about your language\n\n# Next, you'll want to declare the syntax of your language. This is done in a Syntax-section:\n\n Syntax\n========\n\n\n# `a` is a simple example of an syntactic form\n# Here, you define a simple syntactic form named 'a', which can be \"T\", can be \"F\", can be \"(T)\", \"(F)\", or even \"(((T)))\"\n# Lines a whitespace insensitive by default, so `a` could be \"(T   )\" or \"(\\tF )\" as well\n# Note that text above a syntactic form is considered documentation as well an can be queried from the REPL\na\t::= \"T\" | \"F\" | \"(\" a \")\"\n\n# These are builtins offered by the import. You can remove this syntactic form\nbuiltins\t::= identifier | identifierUpper | string | unicodeChar\n\t\t| upper | lower | digit | lineChar | wordChar\n\t\t| number | integer\n\n\n# If you don't want whitespace insensitivity by default, use `~~=` instead of `::=`\n# This one would match `TT` and `TF`, but *not* `T T` or `T\\tF`\n# Note that `a` itself might still contain whitespace, e.g. `(T )(F)` or `(T)(\\tf\\t)`\nwhitespaceSensitiveLine\t\t~~= a a\n\n# This one does match `T T`\nwhitespaceInsensitiveLine\t\t::= a a\n\n\n# A small language could contain following syntactic forms:\n\n\n# A truth value\nbool\t::= \"True\" | \"False\"\n\n# A value, which can be a bool or a number\nvalue\t::= bool\n\t| integer\t# integer is defined within the builtins\n\n# An expression, which is a value, an operator and another expression\nexpr\t::= value \"&\" expr | value \"+\" expr | value \"=\" value | value\n\n# The types that our language has\ntype\t::= \"Bool\" | \"Int\"\n\n Functions\n===========\n\n# Small helper functions go here. They serve to capture small reduction rules, which might be cumbersome to write as a full relation\n# They start with the signature ( functionName \":\" typeName \"*\" typeName \"->\" typeName)\n# Clauses pattern match as in haskell\n# As usual, the comments above a function count as docstring:\n\n\n# The truth value resulting from the logical AND-operation\nand\t\t: bool * bool -> bool\nand(\"True\", \"True\")\n\t\t= \"True\"\nand(_, _)\t= \"False\"\n\n\n\n\n# Returns true if both arguments are the same\neqBool\t\t: bool * bool -> bool\neqBool(\"True\", \"True\")\n\t\t= \"True\"\neqBool(\"False\", \"False\")\n\t\t= \"True\"\neqBool(_, _)\t= \"False\"\n\n# Compares two numbers for equality\neqInt\t\t: integer * integer -> bool\neqInt(i, i)\t= \"True\"\t\t# Here, we use the pattern matching to check for equality\neqInt(_, _)\t= \"False\"\n\n\n# No plus for numbers, as this is a builtin function\n\n\n\n Relations\n============\n\n# Next up are relations. Relations can be used for anything\n# Most commonly, they are used for typecheckers and evaluators\n# Here, relations are only declared.\n# This is by giving a symbol between arrows, followed by what types it relates\n# The mode `(in)` or `(out)` helps the algorithm. It is crucial to order the information flow through the rules\n\n# Again, text above a rule is considered a docstring\n\n# A single step in the evaluation\n# (To produce \8594 on linux: type Ctrl+U, release them, type 2192, press enter or space)\n# (As this is a relation you declare yourself, you can also choose another symbol such as ->; -->; ...)\n(\8594)\t: expr (in) * expr (out); Pronounced as \"small step\"\n\n# Type the expression\n(::)\t: expr (in) * type (out); Pronounced as \"type as\"\n\n Rules\n=======\n\n\n# A rule is defined by dashes, followed by a rule name:\n#\n# -------------------- [Rule name goes here]\n#\n\n# Under the rule, a part of the relation is declared, e.g. that `a & b` will reduce to the logical AND of them: `and(a, b)`\n#\n# ---------------------[Eval And]\n# (\8594) a \"&\" b, and(a, b)\n\n# As we declared the first argument to be of mode in, this will be used as pattern match\n# This can be seen in ![RuleExample](RuleSimple.svg)\n\n\n# Above the line, predicates can be given (seperated by tabs, not spaces):\n\n\n  a : bool\tb : bool\n ------------------------- [Eval And]\n  (\8594) a \"&\" b, and(a, b)\n\n\n\n\n  (::) a, \"Bool\"\t(::) b, \"Bool\"\n -------------------------------------- [Type And]\n  (::) a \"&\" b, \"Bool\"\n\n\n  (::) a, \"Int\"\t\t(::) b, \"Int\"\n -------------------------------------- [Type Plus]\n  (::) a \"+\" b, \"Int\"\n\n\n  (::) a, type\t\t(::) b, type\n-------------------------------------- [Type Eq]\n  (::) a \"=\" b, type\n\n\n\n"
_Resources_RuleSimple_svg
	 = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<svg\n   xmlns:dc=\"http://purl.org/dc/elements/1.1/\"\n   xmlns:cc=\"http://creativecommons.org/ns#\"\n   xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\n   xmlns:svg=\"http://www.w3.org/2000/svg\"\n   xmlns=\"http://www.w3.org/2000/svg\"\n   xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n   xmlns:sodipodi=\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\"\n   xmlns:inkscape=\"http://www.inkscape.org/namespaces/inkscape\"\n   version=\"1.1\"\n   width=\"600\"\n   height=\"360\"\n   viewBox=\"0 0 600 360\"\n   id=\"svg2\"\n   inkscape:version=\"0.91 r13725\"\n   sodipodi:docname=\"RuleSimple.svg\">\n  <metadata\n     id=\"metadata80\">\n    <rdf:RDF>\n      <cc:Work\n         rdf:about=\"\">\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource=\"http://purl.org/dc/dcmitype/StillImage\" />\n        <dc:title />\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <defs\n     id=\"defs78\">\n    <marker\n       inkscape:isstock=\"true\"\n       style=\"overflow:visible;\"\n       id=\"marker5971\"\n       refX=\"0.0\"\n       refY=\"0.0\"\n       orient=\"auto\"\n       inkscape:stockid=\"Arrow1Lend\">\n      <path\n         transform=\"scale(0.8) rotate(180) translate(12.5,0)\"\n         style=\"fill-rule:evenodd;stroke:#000000;stroke-width:1pt;stroke-opacity:1;fill:#000000;fill-opacity:1\"\n         d=\"M 0.0,0.0 L 5.0,-5.0 L -12.5,0.0 L 5.0,5.0 L 0.0,0.0 z \"\n         id=\"path5973\" />\n    </marker>\n    <marker\n       inkscape:stockid=\"Arrow1Lend\"\n       orient=\"auto\"\n       refY=\"0.0\"\n       refX=\"0.0\"\n       id=\"Arrow1Lend\"\n       style=\"overflow:visible;\"\n       inkscape:isstock=\"true\">\n      <path\n         id=\"path5650\"\n         d=\"M 0.0,0.0 L 5.0,-5.0 L -12.5,0.0 L 5.0,5.0 L 0.0,0.0 z \"\n         style=\"fill-rule:evenodd;stroke:#000000;stroke-width:1pt;stroke-opacity:1;fill:#000000;fill-opacity:1\"\n         transform=\"scale(0.8) rotate(180) translate(12.5,0)\" />\n    </marker>\n    <marker\n       inkscape:stockid=\"Arrow1Lend\"\n       orient=\"auto\"\n       refY=\"0.0\"\n       refX=\"0.0\"\n       id=\"marker5015\"\n       style=\"overflow:visible;\"\n       inkscape:isstock=\"true\"\n       inkscape:collect=\"always\">\n      <path\n         id=\"path5017\"\n         d=\"M 0.0,0.0 L 5.0,-5.0 L -12.5,0.0 L 5.0,5.0 L 0.0,0.0 z \"\n         style=\"fill-rule:evenodd;stroke:#000000;stroke-width:1pt;stroke-opacity:1;fill:#000000;fill-opacity:1\"\n         transform=\"scale(0.8) rotate(180) translate(12.5,0)\" />\n    </marker>\n    <marker\n       inkscape:isstock=\"true\"\n       style=\"overflow:visible;\"\n       id=\"marker4316\"\n       refX=\"0.0\"\n       refY=\"0.0\"\n       orient=\"auto\"\n       inkscape:stockid=\"Arrow1Lend\">\n      <path\n         transform=\"scale(0.8) rotate(180) translate(12.5,0)\"\n         style=\"fill-rule:evenodd;stroke:#000000;stroke-width:1pt;stroke-opacity:1;fill:#000000;fill-opacity:1\"\n         d=\"M 0.0,0.0 L 5.0,-5.0 L -12.5,0.0 L 5.0,5.0 L 0.0,0.0 z \"\n         id=\"path4318\" />\n    </marker>\n    <marker\n       inkscape:stockid=\"Arrow1Lstart\"\n       orient=\"auto\"\n       refY=\"0.0\"\n       refX=\"0.0\"\n       id=\"Arrow1Lstart\"\n       style=\"overflow:visible\"\n       inkscape:isstock=\"true\">\n      <path\n         id=\"path4247\"\n         d=\"M 0.0,0.0 L 5.0,-5.0 L -12.5,0.0 L 5.0,5.0 L 0.0,0.0 z \"\n         style=\"fill-rule:evenodd;stroke:#000000;stroke-width:1pt;stroke-opacity:1;fill:#000000;fill-opacity:1\"\n         transform=\"scale(0.8) translate(12.5,0)\" />\n    </marker>\n    <linearGradient\n       inkscape:collect=\"always\"\n       id=\"linearGradient4250\">\n      <stop\n         style=\"stop-color:#000000;stop-opacity:1;\"\n         offset=\"0\"\n         id=\"stop4252\" />\n      <stop\n         style=\"stop-color:#000000;stop-opacity:0;\"\n         offset=\"1\"\n         id=\"stop4254\" />\n    </linearGradient>\n    <linearGradient\n       inkscape:collect=\"always\"\n       xlink:href=\"#linearGradient4250\"\n       id=\"linearGradient4256\"\n       x1=\"24.783699\"\n       y1=\"107.14982\"\n       x2=\"44.260262\"\n       y2=\"107.14982\"\n       gradientUnits=\"userSpaceOnUse\" />\n  </defs>\n  <sodipodi:namedview\n     pagecolor=\"#ffffff\"\n     bordercolor=\"#666666\"\n     borderopacity=\"1\"\n     objecttolerance=\"10\"\n     gridtolerance=\"10\"\n     guidetolerance=\"10\"\n     inkscape:pageopacity=\"0\"\n     inkscape:pageshadow=\"2\"\n     inkscape:window-width=\"1920\"\n     inkscape:window-height=\"1056\"\n     id=\"namedview76\"\n     showgrid=\"false\"\n     inkscape:zoom=\"2.1851852\"\n     inkscape:cx=\"261.42055\"\n     inkscape:cy=\"176.98296\"\n     inkscape:window-x=\"0\"\n     inkscape:window-y=\"24\"\n     inkscape:window-maximized=\"1\"\n     inkscape:current-layer=\"layer3\"\n     inkscape:snap-text-baseline=\"true\" />\n  <rect\n     x=\"52\"\n     y=\"86\"\n     width=\"-3\"\n     height=\"14\"\n     fill=\"#ffffff\"\n     fill-opacity=\"1.0\"\n     id=\"rect44\" />\n  <text\n     xml:space=\"preserve\"\n     style=\"font-style:normal;font-weight:normal;font-size:40px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#ff0000;fill-opacity:1;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:0\"\n     x=\"78.254234\"\n     y=\"329.49152\"\n     id=\"text4228\"\n     sodipodi:linespacing=\"125%\"><tspan\n       sodipodi:role=\"line\"\n       id=\"tspan4230\"\n       x=\"78.254234\"\n       y=\"329.49152\"\n       style=\"fill:#ff0000;fill-opacity:1;stroke:#000000;stroke-opacity:0\" /></text>\n  <text\n     xml:space=\"preserve\"\n     style=\"font-style:normal;font-weight:normal;font-size:40px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#ff0000;fill-opacity:1;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:0\"\n     x=\"133.88481\"\n     y=\"330.79932\"\n     id=\"text4228-5\"\n     sodipodi:linespacing=\"125%\"><tspan\n       sodipodi:role=\"line\"\n       x=\"133.88481\"\n       y=\"330.79932\"\n       style=\"fill:#ff0000;fill-opacity:1;stroke:#000000;stroke-opacity:0\"\n       id=\"tspan4276\" /></text>\n  <g\n     inkscape:groupmode=\"layer\"\n     id=\"layer1\"\n     inkscape:label=\"BG\"\n     style=\"display:none\">\n    <rect\n       style=\"fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:2.21915579;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:0\"\n       id=\"rect4207\"\n       width=\"602.67975\"\n       height=\"368.80438\"\n       x=\"-0.15849383\"\n       y=\"-2.8212473\" />\n  </g>\n  <g\n     inkscape:groupmode=\"layer\"\n     id=\"layer3\"\n     inkscape:label=\"Rule\"\n     sodipodi:insensitive=\"true\">\n    <path\n       d=\"m 413.48353,79.652545 -280.18739,0\"\n       id=\"path8-6\"\n       inkscape:connector-curvature=\"0\"\n       style=\"stroke:#000000;stroke-width:7.48581839;stroke-linecap:round;stroke-opacity:0.36305733\" />\n    <text\n       xml:space=\"preserve\"\n       style=\"font-style:normal;font-weight:normal;font-size:40px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:0.36862745;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1\"\n       x=\"131.59322\"\n       y=\"110.54238\"\n       id=\"text4229\"\n       sodipodi:linespacing=\"125%\"><tspan\n         sodipodi:role=\"line\"\n         id=\"tspan4231\"\n         x=\"131.59322\"\n         y=\"110.54238\"\n         style=\"font-size:25px;fill:#000000;fill-opacity:0.36862745\">a &quot;+&quot; b  ~&gt;  !plus(a,b)</tspan></text>\n    <text\n       x=\"509.33206\"\n       y=\"84.720947\"\n       font-size=\"20\"\n       id=\"text24-7\"\n       style=\"font-size:20px;font-family:mono;text-anchor:middle;fill:#000000;fill-opacity:0.36942677\">[ExampleRule]</text>\n    <text\n       xml:space=\"preserve\"\n       style=\"font-style:normal;font-weight:normal;font-size:40px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1\"\n       x=\"254.44067\"\n       y=\"87.254242\"\n       id=\"text4220\"\n       sodipodi:linespacing=\"125%\"><tspan\n         sodipodi:role=\"line\"\n         id=\"tspan4222\"\n         x=\"254.44067\"\n         y=\"87.254242\" /></text>\n  </g>\n  <g\n     inkscape:groupmode=\"layer\"\n     id=\"layer2\"\n     inkscape:label=\"Rest\"\n     style=\"display:inline\">\n    <path\n       d=\"m 134.48698,241.94825 -38.588,25.72533\"\n       id=\"path6\"\n       inkscape:connector-curvature=\"0\"\n       style=\"stroke:#000000;stroke-width:2.57253289;stroke-linecap:round\" />\n    <path\n       d=\"m 134.48698,241.94825 0,25.72533\"\n       id=\"path8\"\n       inkscape:connector-curvature=\"0\"\n       style=\"stroke:#000000;stroke-width:2.57253289;stroke-linecap:round\" />\n    <path\n       d=\"m 134.48698,241.94825 38.588,25.72533\"\n       id=\"path10\"\n       inkscape:connector-curvature=\"0\"\n       style=\"stroke:#000000;stroke-width:2.57253289;stroke-linecap:round\" />\n    <text\n       x=\"134.48697\"\n       y=\"223.94052\"\n       font-size=\"20\"\n       id=\"text24\"\n       style=\"font-size:25.72532845px;font-family:mono;text-anchor:middle;fill:#000000\" />\n    <circle\n       r=\"5.1450658\"\n       cx=\"134.48697\"\n       cy=\"241.94827\"\n       id=\"circle26\"\n       style=\"fill:#000000\" />\n    <text\n       x=\"95.898987\"\n       y=\"306.26157\"\n       font-size=\"20\"\n       id=\"text40\"\n       style=\"font-size:25.72532845px;font-family:mono;text-anchor:middle;fill:#000000\">20</text>\n    <circle\n       r=\"5.1450658\"\n       cx=\"95.898987\"\n       cy=\"267.67355\"\n       id=\"circle42\"\n       style=\"fill:#000000\" />\n    <text\n       x=\"134.48697\"\n       y=\"306.26157\"\n       font-size=\"20\"\n       id=\"text56\"\n       style=\"font-size:25.72532845px;font-family:mono;text-anchor:middle;fill:#000000\">+</text>\n    <circle\n       r=\"5.1450658\"\n       cx=\"134.48697\"\n       cy=\"267.67355\"\n       id=\"circle58\"\n       style=\"fill:#000000\" />\n    <text\n       x=\"173.075\"\n       y=\"306.26157\"\n       font-size=\"20\"\n       id=\"text72\"\n       style=\"font-size:25.72532845px;font-family:mono;text-anchor:middle;fill:#000000\">22</text>\n    <circle\n       r=\"5.1450658\"\n       cx=\"173.075\"\n       cy=\"267.67355\"\n       id=\"circle74\"\n       style=\"fill:#000000\" />\n    <ellipse\n       style=\"fill:#000000;fill-opacity:0;stroke:#000000;stroke-width:2;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n       id=\"path4233\"\n       cx=\"133.88136\"\n       cy=\"258.87286\"\n       rx=\"76.423729\"\n       ry=\"72.076271\" />\n    <ellipse\n       style=\"fill:#000000;fill-opacity:0;stroke:#000000;stroke-width:1.62001038;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n       id=\"path4792\"\n       cx=\"180.33051\"\n       cy=\"104.01697\"\n       rx=\"50.353466\"\n       ry=\"23.528978\" />\n    <ellipse\n       style=\"fill:#00ff00;fill-opacity:0;stroke:#000000;stroke-width:2;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n       id=\"path4809\"\n       cx=\"358.57626\"\n       cy=\"-103.90678\"\n       rx=\"71.342598\"\n       ry=\"22.605307\"\n       transform=\"scale(1,-1)\" />\n    <text\n       xml:space=\"preserve\"\n       style=\"font-style:normal;font-weight:normal;font-size:40px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1\"\n       x=\"34.118656\"\n       y=\"351.4068\"\n       id=\"text5211\"\n       sodipodi:linespacing=\"125%\"><tspan\n         sodipodi:role=\"line\"\n         id=\"tspan5213\"\n         x=\"34.118656\"\n         y=\"351.4068\"\n         style=\"font-size:20px;fill:#000000;fill-opacity:1\">Input argument</tspan></text>\n    <text\n       xml:space=\"preserve\"\n       style=\"font-style:normal;font-weight:normal;font-size:40px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1\"\n       x=\"204.59322\"\n       y=\"26.440681\"\n       id=\"text5215\"\n       sodipodi:linespacing=\"125%\"><tspan\n         sodipodi:role=\"line\"\n         x=\"204.59322\"\n         y=\"26.440681\"\n         id=\"tspan5219\"\n         style=\"font-size:20px\">a := &quot;20&quot;</tspan><tspan\n         sodipodi:role=\"line\"\n         x=\"204.59322\"\n         y=\"51.440681\"\n         id=\"tspan5221\"\n         style=\"font-size:20px\">b := &quot;22&quot;</tspan></text>\n    <text\n       xml:space=\"preserve\"\n       style=\"font-style:normal;font-weight:normal;font-size:40px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1\"\n       x=\"407.32742\"\n       y=\"153.58537\"\n       id=\"text5211-5-2\"\n       sodipodi:linespacing=\"125%\"><tspan\n         sodipodi:role=\"line\"\n         x=\"407.32742\"\n         y=\"153.58537\"\n         style=\"font-size:20px;fill:#000000;fill-opacity:1\"\n         id=\"tspan5341-9\">Construction</tspan></text>\n    <text\n       x=\"411.86029\"\n       y=\"273.61932\"\n       font-size=\"20\"\n       id=\"text72-9\"\n       style=\"font-size:47.52610016px;font-family:mono;text-anchor:middle;fill:#000000\"\n       transform=\"scale(0.99172515,1.0083439)\">42</text>\n    <text\n       xml:space=\"preserve\"\n       style=\"font-style:normal;font-weight:normal;font-size:40px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1\"\n       x=\"321.43616\"\n       y=\"350.97269\"\n       id=\"text5211-3\"\n       sodipodi:linespacing=\"125%\"><tspan\n         sodipodi:role=\"line\"\n         id=\"tspan5213-6\"\n         x=\"321.43616\"\n         y=\"350.97269\"\n         style=\"font-size:20px;fill:#000000;fill-opacity:1\">Output argument</tspan></text>\n    <ellipse\n       ry=\"72.076271\"\n       rx=\"76.423729\"\n       cy=\"256.58472\"\n       cx=\"415.32205\"\n       id=\"ellipse4308\"\n       style=\"fill:#000000;fill-opacity:0;stroke:#000000;stroke-width:2;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\" />\n    <path\n       style=\"fill:none;fill-rule:evenodd;stroke:#000000;stroke-width:2;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1;marker-end:url(#marker4316)\"\n       d=\"m 214.62711,84.508477 c 0,0 35.23729,-52.169491 81.91526,1.830508\"\n       id=\"path5365\"\n       inkscape:connector-curvature=\"0\" />\n    <path\n       style=\"fill:none;fill-rule:evenodd;stroke:#000000;stroke-width:2;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1;marker-end:url(#marker5015)\"\n       d=\"m 137.74576,187.47458 39.35593,-59.94915\"\n       id=\"path5949\"\n       inkscape:connector-curvature=\"0\" />\n    <text\n       xml:space=\"preserve\"\n       style=\"font-style:normal;font-weight:normal;font-size:40px;line-height:125%;font-family:sans-serif;text-align:end;letter-spacing:0px;word-spacing:0px;text-anchor:end;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1\"\n       x=\"132.67659\"\n       y=\"142.70079\"\n       id=\"text5211-5\"\n       sodipodi:linespacing=\"125%\"><tspan\n         sodipodi:role=\"line\"\n         x=\"132.67659\"\n         y=\"142.70079\"\n         style=\"font-size:20px;text-align:end;text-anchor:end;fill:#000000;fill-opacity:1\"\n         id=\"tspan5341\">Pattern</tspan><tspan\n         sodipodi:role=\"line\"\n         x=\"132.67659\"\n         y=\"167.70079\"\n         style=\"font-size:20px;text-align:end;text-anchor:end;fill:#000000;fill-opacity:1\"\n         id=\"tspan6559\">matching</tspan></text>\n    <path\n       style=\"fill:none;fill-rule:evenodd;stroke:#000000;stroke-width:2;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1;marker-end:url(#Arrow1Lend)\"\n       d=\"m 361.0678,127.52543 22.42372,58.11864\"\n       id=\"path6545\"\n       inkscape:connector-curvature=\"0\" />\n    <text\n       xml:space=\"preserve\"\n       style=\"font-style:normal;font-weight:normal;font-size:40px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1\"\n       x=\"300.93985\"\n       y=\"107.27525\"\n       id=\"text4222\"\n       sodipodi:linespacing=\"125%\"><tspan\n         sodipodi:role=\"line\"\n         id=\"tspan4224\"\n         x=\"300.93985\"\n         y=\"107.27525\" /></text>\n  </g>\n</svg>\n"
_Resources_Readme_md
	 = "This document contains various resources, such as docs and others.\n\nInterpreterHelp.md is shown in the interpreter in the help function\nTemplate.language is the template that is dumped when this option is given.\n"
_TestInput_LoopingSupertypes_language
	 = "\n LoopingSupertypes \n*******************\n\n# For testing\n\n Syntax\n========\n\nbool\t::= bool\nx\t::= y\ny\t::= z\nz\t::= x\n\n\n"
_TestInput_Faulty_TitleMismatch_language
	 = "\n Some Other Title\n*******************\n\nSyntax\n======\n\na ::= \"a\"\n\n"
_TestInput_Faulty_LeftRecursiveSyntax_language
	 = "\n Left Recursive Syntax\n***********************\n\n Syntax\n========\n\na\t::= b \"x\"\nb\t::= a \"y\"\n\n"
_TestInput_Faulty_FunctionDuplicateNameTest_language
	 = "\n Function Duplicate Name Test\n******************************\n\n# Blabla\n\nSyntax\n======\n\nbool\t::= \"True\" | \"False\"\nint\t::= Number\n\nexpr\t::= bool | int\n\n\n\nFunctions\n=========\n\nnot\t\t: bool -> bool\nnot(\"True\")\t= \"False\"\nnot(\"False\")\t= \"True\"\n\nnot\t\t: bool -> bool\nnot(x)\t\t= x\n"
_TestInput_Faulty_TestShadowing_language
	 = "\n Test Shadowing\n****************\n\n\nSyntax\n======\n\nx\t::= \"a\" | \"a\" \"b\"\ny\t::= bool | bool bool\nz\t::= bool | bool\n\nbool\t::= \"False\" | \"True\"\nint\t::= Number\n\nexpr\t::= bool | int\n\n\ndead1\t::= expr | bool\ndead2\t::= expr | bool \";\"\n\nalive1\t::= bool | expr\nalive2\t::= bool | expr \";\"\n\n"
_TestInput_Faulty_SyntaxUndeclared_language
	 = "\n Syntax Undeclared\n*******************\n\n Syntax\n========\n\na\t::= \"x\" \"y\"\n\n# C is not known\nb\t::= a c\n"
_TestInput_Faulty_FunctionIncorrectNameTest_language
	 = "\n Function Incorrect Name Test\n******************************\n\n# Blabla\n\nSyntax\n======\n\nbool\t::= \"True\" | \"False\"\n\n\n\nFunctions\n=========\n\nnot\t\t: bool -> bool\nf(\"True\")\t= \"False\"\nf(\"False\")\t= \"True\"\n"
_TestInput_Faulty_FunctionTyperTest_language
	 = "\n Function Typer Test\n*********************\n\n# Blabla\n\nSyntax\n======\n\nbool\t::= \"True\" | \"False\"\nint\t::= Number\n\nexpr\t::= bool | int\n\n\n\nFunctions\n=========\n\nnot\t\t: bool -> bool\nnot(\"True\")\t= \"False\"\nnot(\"False\")\t= \"True\"\n\n\nf\t\t: bool -> bool\nf(x)\t\t= y\n\ng\t\t: int -> int\ng(x)\t\t= not(x)\n\nh\t\t: expr -> bool\nh((x:int))\t= bool\nh(x)\t\t= not(x)\n\n"
_TestInput_Faulty_VariableTypingErrors_language
	 = "\n Variable Typing Errors\n************************\n\n# Blabla\n\nSyntax\n======\n\nbool\t::= \"True\" | \"False\"\nint\t::= Number\n\nexpr\t::= bool | int\n\n\n\nFunctions\n=========\n\nnot\t\t: bool -> bool\nf(\"True\")\t= \"False\"\nf(\"False\")\t= \"True\"\n\n\nf\t\t: bool -> bool\nf(x)\t\t= y\n\ng\t\t: int -> int\ng(x)\t\t= not(x)\n\nh\t\t: expr -> bool\ng((x:int))\t= bool\ng(x)\t\t= not(x)\n\n"
_TestInput_Faulty_Relations_NotLocal_language
	 = "\n Not Local\n**************\n\nSyntax\n=======\n\na\t::= \"a\"\n\n\nRelations\n==========\n\n(\8594) : a (in)\n\n\n Rules\n===========\n\n\n-------- [abc]\n(~) a \n\n\n\n\n"
_TestInput_Faulty_Relations_DuplicateRelation_language
	 = "\n Duplicate Relation\n**********************\n\nSyntax\n=======\n\na\t::= \"a\"\n\n Relations\n===========\n\n\n(~) : a (in) * a (out)\n(~) : a (in)\n"
_TestInput_Faulty_Relations_EmptyLine_language
	 = "\n Empty Line\n**********************\n\nSyntax\n=======\n\na\t::= \"True\"\n\n Relations\n===========\n\n\n(~) : a (in) * a (out)\n\n\nRules\n=======\n\n \"True\"\n----------\n (~) x, x\n"
_TestInput_Faulty_Relations_UnknownTypeRelation_language
	 = "\n Unknown Type Relation\n***********************\n\nSyntax\n=======\n\na\t::= \"a\"\n\n Relations\n===========\n\n(~) : x (in) * x (out)\n\n"
_TestInput_Faulty_Relations_IncorrectRule_language
	 = "\n Incorrect Rule\n****************\n\n Syntax\n========\n\na\t::= \"a\"\nb\t::= \"b\"\n\n Relations\n===========\n\n(!) : a (in) * b (out)\n\n Rules\n=======\n\n\n--------------- [one]\n (!) \"a\", \"a\"\n\n\n\n\n--------------- [two]\n (!) x, \"b\"\n\n\n\n--------------- [three]\n (!) \"a\", x\n\n\n\n# correct\n\n--------------- [four]\n (!) x, x\n\n\n\n (!) x, \"b\"\n--------------- [five]\n (!) \"a\", \"b\"\n\n\n (!) \"a\", a\n--------------- [six]\n (!) a, \"b\"\n\n\n"
_TestInput_Faulty_Relations_AllOutRel_language
	 = "\n All Out Rel\n**********************\n\nSyntax\n=======\n\na\t::= \"a\"\n\n Relations\n===========\n\n\n(~) : a (out) * a (out)\n"
_TestInput_Faulty_Relations_NotDeclared_language
	 = "import Relation\n\n Not Declared\n**************\n\nSyntax\n=======\n\na\t::= \"a\"\n\n Rules\n===========\n\n\n-------- [abc]\n(~) a \n\n\n\n\n"
_TestInput_Faulty_Relations_Relation_language
	 = " Relation\n**********\n\nSyntax\n======\n\nx ::= \"x\"\n\nRelations\n==========\n\n(~) : x (in)\n\nRules\n=====\n\n-------- [ x ]\n(~) \"x\"\n"
_TestInput_Faulty_Relations_TypeErr_language
	 = "\n Type Err\n**********\n\n Syntax\n========\n\n\nbool\t::= \"True\" | \"False\"\n\n\nint\t::= Number\n\n Relations\n===========\n\n(!)\t: bool (in)\t; Pronounced as \"not\"\n\n\n Rules\n=======\n\n\n------------ [not]\n (!) \"5\"\n"
_TestInput_Faulty_Relations_UnkownTypeRelation_language
	 = "\n Unknown Type Relation\n***********************\n\nSyntax\n=======\n\na\t::= \"a\"\n\n Relations\n===========\n\n\n(~) : x (in) * x (out)\n\n"
_TestInput_Nested_Z_language
	 = "\n Z\n***\n\nSyntax\n======\n\na ::= \"b\"\n"
_TestInput_Nested_X_language
	 = "import local Y\n\n X\n***\n\nSyntax\n======\n\nx ::= \"M\" | \"F\"\n\nFunctions\n=========\n\nnot\t\t: x -> x\nnot(\"M\")\t= \"F\"\nnot(\"F\")\t= \"M\"\n\n"
_TestInput_Nested_L_language
	 = "import local X\nimport TestInput.Nested.Z\n\n L\n***\n\nSyntax\n======\n\na ::= \"T\" | \"F\"\n\n\nFunctions\n=========\n\n\nnot\t: a -> a\nnot(\"T\")\t= \"F\"\nnot(\"F\")\t= \"T\"\n\n"
_TestInput_Nested_Y_language
	 = "\n Y\n***\n\nSyntax\n======\n\na ::= \"b\"\n"
_ALGT_Builtins_language
	 = " Builtins\n***********\n\n# Contains builtin BNFs and functions.\n# The BNFs offer some often used tokens, such as identifiers, whitespace, or numbers\n# Some functions to perform math with these numbers are provided too. As most of these functions are hardware supported; they do not contain an actual implementation\n\n\n Syntax\n========\n \n# Zero or more whitespace characters. Always produces a token in the parsetree (even if no whitespace was present); [ \\t]*\nwhitespace\t::= Whitespace\n\n# An identifier starting with an uppercase letter; [A-Z][a-zA-Z0-9]*\nidentifierUpper\t::= IdentifierUpper\n\n# An identifier starting with a lowercase letter; [a-z][a-zA-Z0-9]*\nidentifier\t::= Identifier\n\n\nstring\t\t::= String\n\n# Any single character; .\nany\t\t::= Any\n\n# Any single unicode character that is not a standard ascii-character; [^a-zA-Z0-9\\ascii]\nunicodeChar\t::= UnicodeChar\n\n# Any upper character; [A-Z]\nupper\t\t::= Upper\n\n# Any lower character; [a-z]\nlower\t\t::= Lower\n\n# Any digit; [0-9]\ndigit\t\t::= Digit\n\n# Any single character that is not a newline. This includes \\r.; [^\\n]\nlineChar\t::= LineChar\n\n# Any single character that is not a whitespace or newline; [^ \\t\\n]\nwordChar\t::= WordChar\n\n# Matches an (possibly negative) integer. Integers parsed by this might be passed into the builtin arithmetic functions.; -?[0-9]+\ninteger\t\t::= Integer\n\n# Matches an positive number. Integers parsed by this might be passed into the builtin arithmetic functions.; [0-9]+\nnumber\t\t::= Number\n\n\n\n Functions\n===========\n\n# Addition of two numbers\nplus\t\t: integer * integer -> integer\nplus(x, y)\t= x # Substituted by real implementation at runtime\n\n# Subtraction of two numbers\nmin\t\t: integer * integer -> integer\nmin(x, y)\t= x # Substituted by real implementation at runtime\n\n# Multiplication of two numbers\nmul\t\t: integer * integer -> integer\nmul(x, y)\t= x # Substituted by real implementation at runtime\n\n# Integer division of two numbers, floored towards zero \n# > div(-1,2)  \t= 0\ndiv\t\t: integer * integer -> integer\ndiv(x, y)\t= x  # Substituted by real implementation at runtime\n\n# Fraction after division \nmod\t\t: integer * integer -> integer\nmod(x, y)\t= x  # Substituted by real implementation at runtime\n\n\n# Given a string, parses it accoring to the syntax\n# The second argument is a string containing the typename (which is resolved using the scope you call it in): \n# > parse(\"True & False\", \"string\") : boolExpr = \"True\" \"&\" \"False\"\nparse\t\t: \8868 * \8868 -> \8868\nparse(toParse, parseAs)\t= x\t# Substituted by real implementation at runtime\n\n# Given a complex structure, simplifies it to a string\n# > group(\"True\" \"&\" \"False) = \"True&False\"\ngroup\t\t: \8868 -> string\nparse(x)\t= x\t# Substituted by real implementation at runtime\n\n\n# A function which fails with the given error message\nerror\t\t: \8868 -> \8869\nerror(msg)\t= msg\t# Substituted by real implementation at runtime\n\n# A function which fails with the given error message and gives a suggestion on how the user might fix the error\nerrorSugg\t\t: \8868 * \8868 -> \8869\nerrorSugg(msg, sugg)\n\t= msg\t# Substituted by real implementation at runtime\n\n"
_ALGT_Readme_md
	 = "The ALGT package can be imported and contains the standard library. It contains:\n\n- ALGT.Builtins: all builtin bnf-forms and functions (such as plus, parse, ...)\n- ALGT.Native: contains all language definitions of the native language (in which 'these modules' are written) and which the binary loads natively\n- ALGT.Sugared: contains a sugared edition of ALGT, the production language in which most users write ALGT\n"
_ALGT_Native_Syntax_language
	 = "import ALGT.Native.ALGT\nimport ALGT.Native.Functions\nimport ALGT.Native.Helper\nimport ALGT.Native.Relations\nimport ALGT.Native.Syntax\n\n  Syntax \n ********\n\n# Automatically generated; do not edit\n Syntax \n========\n\n\n# The contents of comments, such as what you are reading right now\ncommentContents\t::= LineChar Syntax.commentContents\t\t # Body of the comment\n\t  | \"\\n\"\t\t # Closing of the comment\n\n# A comment\ncomment\t::= \"#\" $Syntax.commentContents\t\n\n# A newline, possibly with a single comment\nnl\t::= Syntax.comment\t\n\t  | \"\\n\"\t\n\n# Multiple nls, possibly with comments\nnls\t::= Syntax.nl Syntax.nls\t\n\t  | Syntax.nl\t\n\n# A wrapper around the String builtin, for ease of use with the typesystem\nstring\t::= String\t\n\n# The names of syntactic forms that are available as builtins\nbuiltin\t::= \"Whitespace\"\t\t # Zero or more whitespace characters. Always produces a token in the parsetree; [ \\t]*\n\t  | \"IdentifierUpper\"\t\t # An identifier starting with an uppercase letter; [A-Z][a-zA-Z0-9]*\n\t  | \"Identifier\"\t\t # An identifier starting with a lowercase letter; [a-z][a-zA-Z0-9]*\n\t  | \"String\"\t\t # A double quoted string, where \\\" is a literal double quote and \\\\ is a literal backslash; \"([^\"]|\\[nt\"\\])\"\n\t  | \"Any\"\t\t # Any single character; .\n\t  | \"UnicodeChar\"\t\t # Any single unicode character that is not a standard ascii-character; [^a-zA-Z0-9\\ascii]\n\t  | \"Upper\"\t\t # Any upper character; [A-Z]\n\t  | \"Lower\"\t\t # Any lower character; [a-z]\n\t  | \"Digit\"\t\t # Any digit; [0-9]\n\t  | \"LineChar\"\t\t # Any single character that is not a newline. This includes \\r.; [^\\n]\n\t  | \"WordChar\"\t\t # Any single character that is not a whitespace or newline; [^ \\t\\n]\n\t  | \"Integer\"\t\t # Matches an (possibly negative) integer. Integers parsed by this might be passed into the builtin arithmetic functions.; -?[0-9]+\n\t  | \"Number\"\t\t # Matches an positive number. Integers parsed by this might be passed into the builtin arithmetic functions.; [0-9]+\n\n# A single term of BNF, thus either a literal, syntactic form call or builtin\nbnfTerm\t::= Syntax.string\t\t # Literal value\n\t  | Syntax.ident\t\t # Syntactic form call in some namespace\n\t  | Syntax.builtin\t\t # Call of a builtin\n\t  | \"$\" Syntax.bnfTerm\t\t # Grouping an entire parsetree to a single token\n\n# A sequence of BNF-terms\nbnfSeq\t::= Syntax.bnfTerm Syntax.bnfSeq\t\n\t  | Syntax.bnfTerm\t\n\n# The separator of choices\nbar\t~~= \"|\"\t\t # A simple bar\n\t  | Syntax.nl \"\\t\" Whitespace \"|\"\t\t # Jumping to a newline\n\n# One or more choices in BNF\nbnfChoices\t::= Syntax.bnfSeq Syntax.bar Syntax.bnfChoices\t\n\t  | Syntax.bnfSeq Syntax.nl\t\n\n# The declaration operator, used to indicate the whitespace mode\nassign\t::= \"::=\"\t\t # Assigment using implicit whitespace\n\t  | \"~~=\"\t\t # Assignment where the programmer is responsible for whitespace\n\n# A line declaring bnf\nbnfDecl\t::= Syntax.nls Identifier Syntax.assign Syntax.bnfChoices\t\t # With comment or leading newlines\n\t  | Identifier Syntax.assign Syntax.bnfChoices\t\n\n# An entire syntax declaration\nsyntax\t::= Syntax.bnfDecl Syntax.syntax\t\n\t  | Syntax.bnfDecl\t\n\n# Identifies something (such as a function, rule, relation, syntactic form, ...);\n#  can be fully qualified or not\nident\t::= IdentifierUpper \".\" Syntax.ident\t\n\t  | Identifier\t\n\n# Identifies a syntactic form; used as types for functions and relations.\n# Can be an identifier, fully qualified identiefier or builtin value\ntypeIdent\t::= \"\8869\"\t\t # The bottom type, when a function will never yield a result\n\t  | \"\8868\"\t\t # The top type, when a function might return any type.\n\t  | Syntax.ident\t\n\n\n"
_ALGT_Native_Functions_language
	 = "import ALGT.Native.Syntax\n\n Functions\n***********\n\n# This file implements the syntax of metafunctions\n# As this file is part of the bootstrap for language definitions, only the syntax part can be used. Adding a metafunction section will cause a hang of ALGT\n# This is because, in order to read metafunctions, this language should be fully parsed - if this language would contain metafunctions, it could not be fully evaluated\n\n# Pietervdvn\n\n# Imports are injected fakely\n# Imports are:\n# Syntax (nls, nl, ident, typeIdent)\n#\n\n Syntax\n========\n\n\n\n\n# The symbol between two types in the signature\ntypeSep\t\t::= \"*\"\n\t\t| \"\215\"\t\n\nlastTypeSep\t::= \"->\" | \"\8594\" \n\n\ntypes\t\t::= Syntax.typeIdent typeSep types | Syntax.typeIdent\n\n# The type signature\nsignature\t::= Identifier \":\" types lastTypeSep Syntax.typeIdent\n\t\t|   Identifier \":\" Syntax.typeIdent\t\t\t# This would be a constant\n\n\n\narguments\t::= expression \",\" arguments | expression\nfuncCall\t~~= Syntax.ident \"(\" Whitespace arguments Whitespace \")\"\n\nascription\t::= expressionTerm \":\" Syntax.typeIdent\nsplitExpression\t::= expressionTerm \"&\" expression\n\n# Concatation of expressions; tabs are not allowed\nconcatExpressions\t~~= expressionTerm \" \" expression\n\n# The metaExpressions/patterns that can be used (note: the comments are in a special format: example, name, behaviour in patterns, behaviour in arguments)\n# If a function can not match any expression, an error is generated\nexpressionTerm\t::= funcCall\t# \"f(a, 5)\", \"Function call\", \"Evaluates the function, matches if the argument equals the result. Can only use variables which are declared left of this pattern. If the function fails (gives an error), the pattern fails too and the next clause is tried\", \"Evaluate this function\"\n\t\t| Identifier\t#  \"x\",\t\"Variable\",\"Captures the argument as the name. If multiple are used in the same pattern, the captured arguments should be the same or the match fails.\"\n\t\t| \"_\"\t\t# \"_\", \"Wildcard\", \"Captures the argument and ignores it\", \"_Not defined_\"\n\t\t| Number\t# \"42\", \"Number\", \"Argument should be exactly this number\", \"This number\"\n\t\t| String \t# \"Token\", \"Literal\", \"Argument should be exactly this string\", \"This string\"\n\t\t| \"(\" expression \")\"\t# \"(x y z)\", \"Parens\", \"Groups a pattern\", \"Groups an expression\"\n\n\n# A full expression, eventually a sequence\nexpression\t::=  ascription\t# \"a:type\", \"Ascription\", \"Check that the argument is an element of `type`\", \"Checks that an expression is of a type. Bit useless to use within expressions\"\n\t\t| splitExpression # \"x&y\", \"Capture\", \"Match the argument against both patterns\", \"Execute both `x` and `y`, check that they are the same\"\n\t\t| concatExpressions\n\t\t| expressionTerm\n\n# A single clause in a metafunction\neqSign\t\t~~= Syntax.nl \"\\t\" Whitespace \"=\" | \"=\"\nfuncClause\t::= Identifier \"(\" arguments \")\" eqSign expression Syntax.nl\nfuncClauses\t::= funcClause funcClauses | funcClause\n\n# A full function, including leading docstring\nfunction\t::= Syntax.nls signature Syntax.nl funcClauses\n\n# Full function section definition\nfunctions\t::= function functions | function\n\n\n"
_ALGT_Native_ALGT_language
	 = "import ALGT.Native.ALGT\nimport ALGT.Native.Functions\nimport ALGT.Native.Helper\nimport ALGT.Native.Relations\nimport ALGT.Native.Syntax\n\n  ALGT \n ******\n\n# Automatically generated; do not edit\n Syntax \n========\n\n\n\nstars\t::= \"*\" ALGT.stars\t\n\t  | \"*\"\t\n\n\ndashes\t::= \"-\" ALGT.dashes\t\n\t  | \"-\"\t\n\n\neqs\t::= \"=\" ALGT.eqs\t\n\t  | \"=\"\t\n\n\nlineContents\t::= LineChar ALGT.lineContents\t\n\t  | \"\\n\"\t\n\n\ncomment\t::= \"#\" $ALGT.lineContents\t\n\n\ntitle\t::= ALGT.imports $ALGT.lineContents $ALGT.stars Syntax.nls\t\n\t  | $ALGT.lineContents $ALGT.stars Syntax.nls\t\n\n\nnamespace\t~~= IdentifierUpper \".\" ALGT.namespace\t\n\t  | IdentifierUpper\t\n\n\nimportStm\t::= \"import\" \"local\"\t\n\t  | \"import\"\t\n\n\nimport\t::= Syntax.nls ALGT.importStm ALGT.namespace\t\n\t  | ALGT.importStm ALGT.namespace\t\n\n\nimports\t::= ALGT.import ALGT.imports\t\n\t  | Syntax.nls\t\n\n\ntitleSyntax\t::= \"Syntax\" Syntax.nl ALGT.eqs Syntax.nl\t\n\n\ntitleFunctions\t::= \"Functions\" Syntax.nl ALGT.eqs Syntax.nl\t\n\n\ntitleRelations\t::= \"Relations\" Syntax.nl ALGT.eqs Syntax.nl\t\n\n\ntitleRules\t::= \"Rules\" Syntax.nl ALGT.eqs Syntax.nl\t\n\n\nmoduleSyntax\t::= ALGT.titleSyntax Syntax.syntax Syntax.nls\t\n\t  | ALGT.titleSyntax Syntax.syntax\t\n\n\nmoduleFunctions\t::= ALGT.titleFunctions Functions.functions Syntax.nls\t\n\t  | ALGT.titleFunctions Functions.functions\t\n\n\nmoduleRelations\t::= ALGT.titleRelations Relations.relations Syntax.nls\t\n\t  | ALGT.titleRelations Relations.relations\t\n\n\nmoduleRules\t::= ALGT.titleRules Relations.rules Syntax.nls\t\n\t  | ALGT.titleRules Relations.rules\t\n\n\nmodules\t::= ALGT.moduleSyntax ALGT.moduleFunctions ALGT.moduleRelations ALGT.moduleRules\t\n\t  | ALGT.moduleSyntax ALGT.moduleFunctions ALGT.moduleRules\t\n\t  | ALGT.moduleSyntax ALGT.moduleFunctions ALGT.moduleRelations\t\n\t  | ALGT.moduleSyntax ALGT.moduleRelations ALGT.moduleRules\t\n\t  | ALGT.moduleSyntax ALGT.moduleRules\t\n\t  | ALGT.moduleSyntax ALGT.moduleRelations\t\n\t  | ALGT.moduleSyntax ALGT.moduleFunctions\t\n\t  | ALGT.moduleFunctions ALGT.moduleRelations ALGT.moduleRules\t\n\t  | ALGT.moduleFunctions ALGT.moduleRules\t\n\t  | ALGT.moduleFunctions ALGT.moduleRelations\t\n\t  | ALGT.moduleRelations ALGT.moduleRules\t\n\t  | ALGT.moduleRules\t\n\t  | ALGT.moduleRelations\t\n\t  | ALGT.moduleFunctions\t\n\t  | ALGT.moduleSyntax\t\n\n\nlangDef\t::= ALGT.title ALGT.modules\t\n\n\n"
_ALGT_Native_Helper_language
	 = "import ALGT.Native.ALGT\nimport ALGT.Native.Functions\nimport ALGT.Native.Helper\nimport ALGT.Native.Relations\nimport ALGT.Native.Syntax\n\n  Helper \n ********\n\n# Automatically generated; do not edit\n Syntax \n========\n\n\n# The contents of comments, such as what you are reading right now\ncommentContents\t::= LineChar Syntax.commentContents\t\t # Body of the comment\n\t  | \"\\n\"\t\t # Closing of the comment\n\n# A comment\ncomment\t::= \"#\" $Syntax.commentContents\t\n\n# A newline, possibly with a single comment\nnl\t::= Syntax.comment\t\n\t  | \"\\n\"\t\n\n# Multiple nls, possibly with comments\nnls\t::= Syntax.nl Syntax.nls\t\n\t  | Syntax.nl\t\n\n\n"
_ALGT_Native_Relations_language
	 = "\nimport ALGT.Native.Functions\nimport ALGT.Native.Syntax\nimport ALGT.Native.ALGT\n\n Relations \n***********\n\n\n# This document contains the syntax for relations and the natural deduction rules containing them.\n# This syntax reuses many expressions from functions; so \"Functions\" will be seen often\n\n# Because this document is loaded with the bootstrapper, all outside links should be fully qualified\n\n Syntax\n========\n\n# ==================== Relation declaring section ===================\n\n# -------------------- Identifiers of relations ---------------------\n\nsymbolChar\t::= UnicodeChar \n\t\t| \"*\" | \"/\" | \"\\\\\"\n\t\t| \"+\" | \"-\"\n\t\t| \"!\" | \"#\" | \"$\" | \"%\" | \".\" | \"~\"\n\t\t| \"=\" | \"<\" | \">\" | \"?\" | \"@\" | \"^\"\n\t\t| \"_\" | \":\"\n\t\t| Digit\nsymbol\t\t::= symbolChar relIdent | symbolChar\nrelIdent\t::= Identifier \".\" relIdent | $symbol\n\n\n# -------------------- Parts of the declaration ---------------------\n\n# The mode (input/output)\nmode\t\t::= \"in\" | \"out\"\ntype\t\t::= Syntax.typeIdent \"(\" mode \")\"\n# Full type: ` bool (in) * bool (out)`\ntypes\t\t::= type Functions.typeSep types | type\n\n# The actually relevant part\nrelDeclarationCore\t::= \"(\" $symbol \")\" \":\" types\n# The optional prononciation\nrelPronounce\t::= \";\" \"Pronounced\" \"as\" String Syntax.nl | Syntax.nl\nrelation\t::= Syntax.nls relDeclarationCore relPronounce  | relDeclarationCore relPronounce\n\n\n# -------------------- The relation declaration section -------------\n\nrelations\t::= relation relations | relation\n\n# ==================== Actual Rules ==================================\n\n# Expressions, comma seperated for use as arguments for a relation\ncommaSepExpr\t::= Functions.expression \",\" commaSepExpr | Functions.expression\n\n\n# Some conclusion about a relation\nconclusion\t::= \"(\" relIdent \")\" commaSepExpr\n\n# A single predicate that should be met\n# A lonely expression should evaluate without error\n# A predicate with a relation should hold\npredicate\t::= conclusion\n\t\t| Functions.expression\n\ntabs\t\t~~= \"\\t\" tabs | \"\\t\"\npredicates\t~~= predicate tabs predicates | predicate\n\n\nruleChar\t::= Lower | Upper | Digit\nruleName\t::= ruleChar ruleName | ruleChar\n\nline\t\t::= $ALGT.dashes \"[\" $ruleName \"]\"\n\t\t| $ALGT.dashes\n\n\nrule\t\t::= Syntax.nls predicates Syntax.nl line Syntax.nl conclusion Syntax.nl\n\t\t| Syntax.nls line Syntax.nl conclusion Syntax.nl\n\nrules\t\t::= rule rules | rule\n\n\n"
_ALGT_Sugared_Syntax_language
	 = "import ALGT.Builtins\n\nimport ALGT.Native.Syntax\n\n Syntax\n********\n\n# The sugared syntax edition for ALGT\n\n Syntax\n========\n\n# A single term of BNF, thus either a literal, syntactic form call or builtin\nbnfTerm\t\t::= ALGT.Native.Syntax.string\t\t\t\t\t # Literal value\n\t\t  | Native.Syntax.ident\t\t\t\t # Syntactic form call in some namespace\n\t\t  | \"$\" bnfTerm\t\t\t\t\t # Grouping an entire parsetree to a single token\n\nbnfOp\t\t::= \"?\" | \"*\" | \"+\"\n\n# A sequence of BNF-terms\nbnfSeq\t\t~~= bnfTerm bnfOp whitespace bnfSeq\n\t\t  | bnfTerm whitespace bnfSeq\t\n\t\t  | bnfTerm\t\n\n# One or more choices in BNF\nbnfChoices\t::= bnfSeq bar bnfChoices\t\n\t\t  | bnfSeq nl\t\n\n# A line declaring bnf\nbnfDecl\t\t::= nls Identifier assign bnfChoices\t\t # With comment or leading newlines\n\t\t  | Identifier assign bnfChoices\t\n\n# An entire syntax declaration\nsyntax\t\t::= bnfDecl syntax\t\n\t\t  | bnfDecl\t\n\t\n\n Functions\n===========\n\n\n\ndesSeq\t\t: bnfSeq -> ALGT.Native.Syntax.bnfChoices\ndesSeq(term : bnfTerm)\n\t\t= desBNFTerm(term) \"\\n\"\n\n\n\ndesBNFTerm\t\t: bnfTerm -> ALGT.Native.Syntax.bnfTerm\ndesBNFTerm(i : ident)\t= i\ndesBNFTerm(\"$\" t)\t= \"$\" desBNFTerm(t)\ndesBNFTerm(s : Native.Syntax.string)\n\t\t\t= s\n\n"
_MetaSyntax_Syntax_language
	 = "import ALGT.Native.ALGT\nimport ALGT.Native.Functions\nimport ALGT.Native.Helper\nimport ALGT.Native.Relations\nimport ALGT.Native.Syntax\n\n  Syntax \n ********\n\n# Automatically generated; do not edit\n Syntax \n========\n\n\n# The contents of comments, such as what you are reading right now\ncommentContents\t::= LineChar Syntax.commentContents\t\t # Body of the comment\n\t  | \"\\n\"\t\t # Closing of the comment\n\n# A comment\ncomment\t::= \"#\" $Syntax.commentContents\t\n\n# A newline, possibly with a single comment\nnl\t::= Syntax.comment\t\n\t  | \"\\n\"\t\n\n# Multiple nls, possibly with comments\nnls\t::= Syntax.nl Syntax.nls\t\n\t  | Syntax.nl\t\n\n# A wrapper around the String builtin, for ease of use with the typesystem\nstring\t::= String\t\n\n# The names of syntactic forms that are available as builtins\nbuiltin\t::= \"Whitespace\"\t\t # Zero or more whitespace characters. Always produces a token in the parsetree; [ \\t]*\n\t  | \"IdentifierUpper\"\t\t # An identifier starting with an uppercase letter; [A-Z][a-zA-Z0-9]*\n\t  | \"Identifier\"\t\t # An identifier starting with a lowercase letter; [a-z][a-zA-Z0-9]*\n\t  | \"String\"\t\t # A double quoted string, where \\\" is a literal double quote and \\\\ is a literal backslash; \"([^\"]|\\[nt\"\\])\"\n\t  | \"Any\"\t\t # Any single character; .\n\t  | \"UnicodeChar\"\t\t # Any single unicode character that is not a standard ascii-character; [^a-zA-Z0-9\\ascii]\n\t  | \"Upper\"\t\t # Any upper character; [A-Z]\n\t  | \"Lower\"\t\t # Any lower character; [a-z]\n\t  | \"Digit\"\t\t # Any digit; [0-9]\n\t  | \"LineChar\"\t\t # Any single character that is not a newline. This includes \\r.; [^\\n]\n\t  | \"WordChar\"\t\t # Any single character that is not a whitespace or newline; [^ \\t\\n]\n\t  | \"Integer\"\t\t # Matches an (possibly negative) integer. Integers parsed by this might be passed into the builtin arithmetic functions.; -?[0-9]+\n\t  | \"Number\"\t\t # Matches an positive number. Integers parsed by this might be passed into the builtin arithmetic functions.; [0-9]+\n\n# A single term of BNF, thus either a literal, syntactic form call or builtin\nbnfTerm\t::= Syntax.string\t\t # Literal value\n\t  | Syntax.ident\t\t # Syntactic form call in some namespace\n\t  | Syntax.builtin\t\t # Call of a builtin\n\t  | \"$\" Syntax.bnfTerm\t\t # Grouping an entire parsetree to a single token\n\n# A sequence of BNF-terms\nbnfSeq\t::= Syntax.bnfTerm Syntax.bnfSeq\t\n\t  | Syntax.bnfTerm\t\n\n# The separator of choices\nbar\t~~= \"|\"\t\t # A simple bar\n\t  | Syntax.nl \"\\t\" Whitespace \"|\"\t\t # Jumping to a newline\n\n# One or more choices in BNF\nbnfChoices\t::= Syntax.bnfSeq Syntax.bar Syntax.bnfChoices\t\n\t  | Syntax.bnfSeq Syntax.nl\t\n\n# The declaration operator, used to indicate the whitespace mode\nassign\t::= \"::=\"\t\t # Assigment using implicit whitespace\n\t  | \"~~=\"\t\t # Assignment where the programmer is responsible for whitespace\n\n# A line declaring bnf\nbnfDecl\t::= Syntax.nls Identifier Syntax.assign Syntax.bnfChoices\t\t # With comment or leading newlines\n\t  | Identifier Syntax.assign Syntax.bnfChoices\t\n\n# An entire syntax declaration\nsyntax\t::= Syntax.bnfDecl Syntax.syntax\t\n\t  | Syntax.bnfDecl\t\n\n# Identifies something (such as a function, rule, relation, syntactic form, ...);\n#  can be fully qualified or not\nident\t::= IdentifierUpper \".\" Syntax.ident\t\n\t  | Identifier\t\n\n# Identifies a syntactic form; used as types for functions and relations.\n# Can be an identifier, fully qualified identiefier or builtin value\ntypeIdent\t::= \"\8869\"\t\t # The bottom type, when a function will never yield a result\n\t  | \"\8868\"\t\t # The top type, when a function might return any type.\n\t  | Syntax.ident\t\n\n\n"
_MetaSyntax_Functions_language
	 = "import ALGT.Native.ALGT\nimport ALGT.Native.Functions\nimport ALGT.Native.Helper\nimport ALGT.Native.Relations\nimport ALGT.Native.Syntax\n\n  Functions \n ***********\n\n# Automatically generated; do not edit\n Syntax \n========\n\n\n# The symbol between two types in the signature\ntypeSep\t::= \"*\"\t\n\t  | \"\215\"\t\n\n\nlastTypeSep\t::= \"->\"\t\n\t  | \"\8594\"\t\n\n\ntypes\t::= Syntax.typeIdent Functions.typeSep Functions.types\t\n\t  | Syntax.typeIdent\t\n\n# The type signature\nsignature\t::= Identifier \":\" Functions.types Functions.lastTypeSep Syntax.typeIdent\t\n\t  | Identifier \":\" Syntax.typeIdent\t\t # This would be a constant\n\n\narguments\t::= Functions.expression \",\" Functions.arguments\t\n\t  | Functions.expression\t\n\n\nfuncCall\t~~= Syntax.ident \"(\" Whitespace Functions.arguments Whitespace \")\"\t\n\n\nascription\t::= Functions.expressionTerm \":\" Syntax.typeIdent\t\n\n\nsplitExpression\t::= Functions.expressionTerm \"&\" Functions.expression\t\n\n# Concatation of expressions; tabs are not allowed\nconcatExpressions\t~~= Functions.expressionTerm \" \" Functions.expression\t\n\n# The metaExpressions/patterns that can be used (note: the comments are in a special format: example, name, behaviour in patterns, behaviour in arguments)\n# If a function can not match any expression, an error is generated\nexpressionTerm\t::= Functions.funcCall\t\t # \"f(a, 5)\", \"Function call\", \"Evaluates the function, matches if the argument equals the result. Can only use variables which are declared left of this pattern. If the function fails (gives an error), the pattern fails too and the next clause is tried\", \"Evaluate this function\"\n\t  | Identifier\t\t # \"x\",\t\"Variable\",\"Captures the argument as the name. If multiple are used in the same pattern, the captured arguments should be the same or the match fails.\"\n\t  | \"_\"\t\t # \"_\", \"Wildcard\", \"Captures the argument and ignores it\", \"_Not defined_\"\n\t  | Number\t\t # \"42\", \"Number\", \"Argument should be exactly this number\", \"This number\"\n\t  | String\t\t # \"Token\", \"Literal\", \"Argument should be exactly this string\", \"This string\"\n\t  | \"(\" Functions.expression \")\"\t\t # \"(x y z)\", \"Parens\", \"Groups a pattern\", \"Groups an expression\"\n\n# A full expression, eventually a sequence\nexpression\t::= Functions.ascription\t\t # \"a:type\", \"Ascription\", \"Check that the argument is an element of `type`\", \"Checks that an expression is of a type. Bit useless to use within expressions\"\n\t  | Functions.splitExpression\t\t # \"x&y\", \"Capture\", \"Match the argument against both patterns\", \"Execute both `x` and `y`, check that they are the same\"\n\t  | Functions.concatExpressions\t\n\t  | Functions.expressionTerm\t\n\n# A single clause in a metafunction\neqSign\t~~= Syntax.nl \"\\t\" Whitespace \"=\"\t\n\t  | \"=\"\t\n\n\nfuncClause\t::= Identifier \"(\" Functions.arguments \")\" Functions.eqSign Functions.expression Syntax.nl\t\n\n\nfuncClauses\t::= Functions.funcClause Functions.funcClauses\t\n\t  | Functions.funcClause\t\n\n# A full function, including leading docstring\nfunction\t::= Syntax.nls Functions.signature Syntax.nl Functions.funcClauses\t\n\n# Full function section definition\nfunctions\t::= Functions.function Functions.functions\t\n\t  | Functions.function\t\n\n\n"
_MetaSyntax_ALGT_language
	 = "import ALGT.Native.ALGT\nimport ALGT.Native.Functions\nimport ALGT.Native.Helper\nimport ALGT.Native.Relations\nimport ALGT.Native.Syntax\n\n  ALGT \n ******\n\n# Automatically generated; do not edit\n Syntax \n========\n\n\n\nstars\t::= \"*\" ALGT.stars\t\n\t  | \"*\"\t\n\n\ndashes\t::= \"-\" ALGT.dashes\t\n\t  | \"-\"\t\n\n\neqs\t::= \"=\" ALGT.eqs\t\n\t  | \"=\"\t\n\n\nlineContents\t::= LineChar ALGT.lineContents\t\n\t  | \"\\n\"\t\n\n\ncomment\t::= \"#\" $ALGT.lineContents\t\n\n\ntitle\t::= ALGT.imports $ALGT.lineContents $ALGT.stars Syntax.nls\t\n\t  | $ALGT.lineContents $ALGT.stars Syntax.nls\t\n\n\nnamespace\t~~= IdentifierUpper \".\" ALGT.namespace\t\n\t  | IdentifierUpper\t\n\n\nimportStm\t::= \"import\" \"local\"\t\n\t  | \"import\"\t\n\n\nimport\t::= Syntax.nls ALGT.importStm ALGT.namespace\t\n\t  | ALGT.importStm ALGT.namespace\t\n\n\nimports\t::= ALGT.import ALGT.imports\t\n\t  | Syntax.nls\t\n\n\ntitleSyntax\t::= \"Syntax\" Syntax.nl ALGT.eqs Syntax.nl\t\n\n\ntitleFunctions\t::= \"Functions\" Syntax.nl ALGT.eqs Syntax.nl\t\n\n\ntitleRelations\t::= \"Relations\" Syntax.nl ALGT.eqs Syntax.nl\t\n\n\ntitleRules\t::= \"Rules\" Syntax.nl ALGT.eqs Syntax.nl\t\n\n\nmoduleSyntax\t::= ALGT.titleSyntax Syntax.syntax Syntax.nls\t\n\t  | ALGT.titleSyntax Syntax.syntax\t\n\n\nmoduleFunctions\t::= ALGT.titleFunctions Functions.functions Syntax.nls\t\n\t  | ALGT.titleFunctions Functions.functions\t\n\n\nmoduleRelations\t::= ALGT.titleRelations Relations.relations Syntax.nls\t\n\t  | ALGT.titleRelations Relations.relations\t\n\n\nmoduleRules\t::= ALGT.titleRules Relations.rules Syntax.nls\t\n\t  | ALGT.titleRules Relations.rules\t\n\n\nmodules\t::= ALGT.moduleSyntax ALGT.moduleFunctions ALGT.moduleRelations ALGT.moduleRules\t\n\t  | ALGT.moduleSyntax ALGT.moduleFunctions ALGT.moduleRules\t\n\t  | ALGT.moduleSyntax ALGT.moduleFunctions ALGT.moduleRelations\t\n\t  | ALGT.moduleSyntax ALGT.moduleRelations ALGT.moduleRules\t\n\t  | ALGT.moduleSyntax ALGT.moduleRules\t\n\t  | ALGT.moduleSyntax ALGT.moduleRelations\t\n\t  | ALGT.moduleSyntax ALGT.moduleFunctions\t\n\t  | ALGT.moduleFunctions ALGT.moduleRelations ALGT.moduleRules\t\n\t  | ALGT.moduleFunctions ALGT.moduleRules\t\n\t  | ALGT.moduleFunctions ALGT.moduleRelations\t\n\t  | ALGT.moduleRelations ALGT.moduleRules\t\n\t  | ALGT.moduleRules\t\n\t  | ALGT.moduleRelations\t\n\t  | ALGT.moduleFunctions\t\n\t  | ALGT.moduleSyntax\t\n\n\nlangDef\t::= ALGT.title ALGT.modules\t\n\n\n"
_MetaSyntax_Helper_language
	 = "import ALGT.Native.ALGT\nimport ALGT.Native.Functions\nimport ALGT.Native.Helper\nimport ALGT.Native.Relations\nimport ALGT.Native.Syntax\n\n  Helper \n ********\n\n# Automatically generated; do not edit\n Syntax \n========\n\n\n# The contents of comments, such as what you are reading right now\ncommentContents\t::= LineChar Syntax.commentContents\t\t # Body of the comment\n\t  | \"\\n\"\t\t # Closing of the comment\n\n# A comment\ncomment\t::= \"#\" $Syntax.commentContents\t\n\n# A newline, possibly with a single comment\nnl\t::= Syntax.comment\t\n\t  | \"\\n\"\t\n\n# Multiple nls, possibly with comments\nnls\t::= Syntax.nl Syntax.nls\t\n\t  | Syntax.nl\t\n\n\n"
_MetaSyntax_Relations_language
	 = "import ALGT.Native.ALGT\nimport ALGT.Native.Functions\nimport ALGT.Native.Helper\nimport ALGT.Native.Relations\nimport ALGT.Native.Syntax\n\n  Relations \n ***********\n\n# Automatically generated; do not edit\n Syntax \n========\n\n\n# ==================== Relation declaring section ===================\n# -------------------- Identifiers of relations ---------------------\nsymbolChar\t::= UnicodeChar\t\n\t  | \"*\"\t\n\t  | \"/\"\t\n\t  | \"\\\\\"\t\n\t  | \"+\"\t\n\t  | \"-\"\t\n\t  | \"!\"\t\n\t  | \"#\"\t\n\t  | \"$\"\t\n\t  | \"%\"\t\n\t  | \".\"\t\n\t  | \"~\"\t\n\t  | \"=\"\t\n\t  | \"<\"\t\n\t  | \">\"\t\n\t  | \"?\"\t\n\t  | \"@\"\t\n\t  | \"^\"\t\n\t  | \"_\"\t\n\t  | \":\"\t\n\t  | Digit\t\n\n\nsymbol\t::= Relations.symbolChar Relations.relIdent\t\n\t  | Relations.symbolChar\t\n\n\nrelIdent\t::= Identifier \".\" Relations.relIdent\t\n\t  | $Relations.symbol\t\n\n# -------------------- Parts of the declaration ---------------------\n# The mode (input/output)\nmode\t::= \"in\"\t\n\t  | \"out\"\t\n\n\ntype\t::= Syntax.typeIdent \"(\" Relations.mode \")\"\t\n\n# Full type: ` bool (in) * bool (out)`\ntypes\t::= Relations.type Functions.typeSep Relations.types\t\n\t  | Relations.type\t\n\n# The actually relevant part\nrelDeclarationCore\t::= \"(\" $Relations.symbol \")\" \":\" Relations.types\t\n\n# The optional prononciation\nrelPronounce\t::= \";\" \"Pronounced\" \"as\" String Syntax.nl\t\n\t  | Syntax.nl\t\n\n\nrelation\t::= Syntax.nls Relations.relDeclarationCore Relations.relPronounce\t\n\t  | Relations.relDeclarationCore Relations.relPronounce\t\n\n# -------------------- The relation declaration section -------------\nrelations\t::= Relations.relation Relations.relations\t\n\t  | Relations.relation\t\n\n# ==================== Actual Rules ==================================\n# Expressions, comma seperated for use as arguments for a relation\ncommaSepExpr\t::= Functions.expression \",\" Relations.commaSepExpr\t\n\t  | Functions.expression\t\n\n# Some conclusion about a relation\nconclusion\t::= \"(\" Relations.relIdent \")\" Relations.commaSepExpr\t\n\n# A single predicate that should be met\n# A lonely expression should evaluate without error\n# A predicate with a relation should hold\npredicate\t::= Relations.conclusion\t\n\t  | Functions.expression\t\n\n\ntabs\t~~= \"\\t\" Relations.tabs\t\n\t  | \"\\t\"\t\n\n\npredicates\t~~= Relations.predicate Relations.tabs Relations.predicates\t\n\t  | Relations.predicate\t\n\n\nruleChar\t::= Lower\t\n\t  | Upper\t\n\t  | Digit\t\n\n\nruleName\t::= Relations.ruleChar Relations.ruleName\t\n\t  | Relations.ruleChar\t\n\n\nline\t::= $ALGT.dashes \"[\" $Relations.ruleName \"]\"\t\n\t  | $ALGT.dashes\t\n\n\nrule\t::= Syntax.nls Relations.predicates Syntax.nl Relations.line Syntax.nl Relations.conclusion Syntax.nl\t\n\t  | Syntax.nls Relations.line Syntax.nl Relations.conclusion Syntax.nl\t\n\n\nrules\t::= Relations.rule Relations.rules\t\n\t  | Relations.rule\t\n\n\n"
_TestLanguages_STFL_language
	 = "import ALGT.Builtins\n\n STFL\n******\n\n# A simply typed functional language; mainly used for testing purposes\n\n Syntax\n========\n\nbaseType\t::= \"Bool\" | \"Int\" | \"(\" type \")\"\ntype\t\t::= baseType \"->\" type | baseType\n\nbool\t::= \"True\" | \"False\"\n\nvar\t::= Identifier\n\nlambda\t::= \"(\" \"\\\\\" var \":\" type \".\" expr \")\"\n\ncanon\t::= bool | integer | var | lambda\n\nbaseExpr ::= canon | \"(\" expr \")\" | \"If\" expr \"Then\" expr \"Else\" expr \n\nintOp\t::= \"+\" \nboolOp\t::= \"&\" \nsameOp\t::= \"=\"\n\nop\t::= intOp | boolOp | sameOp\n\nexpr\t::= baseExpr op expr | baseExpr expr| baseExpr\n\ntypingEnv\t::= var \":\" type typingEnv | \"[]\"\n\n\n Functions\n===========\n\nnot\t: bool -> bool\nnot(\"True\")\t= \"False\"\nnot(\"False\")\t= \"True\"\n\n\nand\t: bool * bool -> bool\nand(\"True\", \"True\")\t= \"True\"\nand(_, _)\t\t= \"False\"\n\n\n# Searches the typing environment\nsearch\t: var * typingEnv -> type\nsearch(x, x \":\" t _)\n\t= t\nsearch(x, _ _ _ te)\n\t= search(x, te)\n\n\ntypeEq\t: type * type -> type\ntypeEq(t, t)\n\t= t\ntypeEq(\"(\" t \")\", t)\n\t= t\ntypeEq(t, \"(\" t \")\")\n\t= t\ntypeEq(ta0 \"->\" tr0, ta1 \"->\" tr1)\n\t= typeEq(ta0, ta1) \"->\" typeEq(tr0, tr1)\n\n\n\n\nsubs\t: var * expr * expr -> expr\nsubs(x, x, replacement)\n\t= replacement\nsubs(x, \"(\" \"\\\\\" x \":\" type \".\" expr \")\", _)\n\t= \"(\" \"\\\\\" x \":\" type \".\" expr \")\"\nsubs(x, \"(\" expr \")\", replacement)\n\t= \"(\" subs(x, expr, replacement) \")\"\nsubs(x, expr0 op expr1, replacement)\n\t= subs(x, expr0, replacement) op subs(x, expr1, replacement)\nsubs(x, \"If\" cond \"Then\" exprT \"Else\" exprF, replacement)\n\t= \"If\" subs(x, cond, replacement) \"Then\" subs(x, exprT, replacement) \"Else\" subs(x, exprF, replacement)\n\n\n\n Relations\n===========\n\n(\8594)\t: expr (in) * expr (out)\n\n(::) : expr (in) * type (out) ; Pronounced as \"empty env\"\n(\8866) : typingEnv (in) * expr (in) * type (out)\n\n Rules\n========\n\n\n\n----------------------------------------------------------------- [EApp]\n (\8594) (\"(\" \"\\\\\" x \":\" typeDom \".\" expr \")\") arg, subs(x, arg, expr)\n\n\n------------------------------ [EPar]\n (\8594) \"(\" expr \")\", expr\n\n\n expr0 : bool\texpr1 : bool    \n------------------------------------------ [EBoolAnd]\n (\8594) expr0 \"&\" expr1, and(expr0, expr1)\n\n\n expr0 : integer\texpr1 : integer    \n------------------------------------------ [EIntPlus]\n (\8594) expr0 \"+\" expr1, plus(expr0, expr1)\n\n\n\n----------------------------------------- [EIfTrue]\n (\8594) \"If\" \"True\" \"Then\" e0 \"Else\" e1, e0\n\n\n\n----------------------------------------- [EIfFalse]\n (\8594) \"If\" \"False\" \"Then\" e0 \"Else\" e1, e1\n\n\n\n\n\n### ------------------------- Rules about Typing ---------------------\n\n\n (\8866) \"[]\", expr, type\n---------------------- [ Type in empty environment ]\n (::) expr, type\n\n\n expr : bool\n---------------------- [TTrue]\n (\8866) _, expr, \"Bool\"\n\n\n expr : integer\n---------------------- [TNumber]\n (\8866) _, expr, \"Int\"\n\n\n x : var\n----------------------------- [TVar]\n (\8866) env, x, search(x, env)\n\n\n (\8866) x \":\" typeDom env, expr, typeCod\n-------------------------------------------------------------------- [TLambda]\n (\8866) env, \"(\" \"\\\\\" x \":\" typeDom \".\" expr \")\", typeDom \"->\" typeCod\n\n\n (\8866) env, f, tDom \"->\" tCod\t(\8866) env, arg, tArg\n------------------------------------------------------- [TApp]\n (\8866) env, f arg, typeEq(tCod, tArg)\n\n\n (\8866) env, expr, type\n------------------------------ [TPar]\n (\8866) env, \"(\" expr \")\", type\n\n\n (\8866) env, expr0, \"Bool\"\t(\8866) env, expr1, \"Bool\"\t\top : boolOp       \n---------------------------------------------------------------------------- [TBoolInfix]\n (\8866) env, expr0 op expr1, \"Bool\"\n\n\n\n (\8866) env, expr0, \"Int\"\t\t(\8866) env, expr1, \"Int\"\t\top : intOp\n---------------------------------------------------------------------------- [TIntInfix]\n (\8866) env, expr0 op expr1, \"Int\"\n\n\n (\8866) env, expr0, t0\t(\8866) env, expr1, t1\n-------------------------------------------- [TSameInfix]\n (\8866) env, expr0 op expr1, typeEq(t0, t1)\n\n\n (\8866) env, cond, \"Bool\"\t\t(\8866) env, e0, t0\t\t(\8866) env, e1, t1\n--------------------------------------------------------------------------------- [TIf]\n (\8866) env, \"If\" cond \"Then\" e0 \"Else\" e1, typeEq(t0, t1)\n\n"
